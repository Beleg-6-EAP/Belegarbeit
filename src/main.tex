%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[acmtog]{acmart}
\usepackage[english,ngerman]{babel}
\usepackage[utf8]{inputenc} 
\usepackage{csquotes}

%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}
    
\copyrightyear{2024}
\acmYear{2024}
\citestyle{acmauthoryear}

\usepackage[figurename=Fig.]{caption}
\usepackage{csquotes}
\setcopyright{none}
\makeatletter
\renewcommand{\fnum@figure}{Abb. \thefigure}
\makeatother
\addto\captionsngerman{\renewcommand{\figurename}{Abb.}}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Enterprise Architektur-Muster}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Julian Bruder}
\authornote{Alle Studierenden trugen zu gleichen Teilen zu dieser Arbeit bei.}
\author{Abdellah Filali}
\authornotemark[1]
\author{Luca Franke}
\authornotemark[1]
\affiliation{%
  \institution{Hochschule für Technik, Wirtschaft und Kultur Leipzig (HTWK Leipzig)}
  \streetaddress{Karl-Liebknecht-Str. 132}
  \city{Leipzig}
  %\state{Ohio}
  \country{Deutschland}
  \postcode{04277}
}
%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Bruder, Filali, Franke}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Blah \ldots
\end{abstract}

\maketitle

\section{Einleitung}
% (Beschreibung von Kontext, Problemen, Anforderungen und Zielen)
Blah \ldots

\section{Grundlagen von Enterprise-Architekturen}
Blah \ldots

\section{Klassische Enterprise-Architekturen}
\subsection{Monolith}
Der Begriff \textit{Monolith} stammt aus dem Altgriechischen und bedeutet \textit{einheitlicher Stein}.
Die monolithische Architektur beschreibt ein Softwarearchitektur-Pattern, die die gesamte Funktionalität
in einer einzigen Anwendung bündelt, wobei ein einzigen Prozess für die Ausführung der Anwendung zuständig ist \cite[1]{mono}.

Anwendungen dieser Architektur bestehen aus eng gekoppelte Komponenten, die von
einander abhängig sind, sodass sie weder eigenständig laufen noch in manchen Fällen
nicht isoliert kompiliert werden können. \cite[485]{mono3}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{images/mono/mono.pdf}
    \caption{Monolith Architektur}
    \label{fig:mono}
\end{figure}

Diese Architektur weist für kleinere Anwendungen gewisse Vorteile auf,
wie eine einfache Testbarkeit, Logging, Deployment, sowie Debugging.
Zudem eine Datenbanksynchronisation ist nicht notwendig, da die
gesamte Daten in einer einzigen Datenbank persistieren. \cite[2]{mono4}

Betrachten wir das E-Commerce-Beispiel.
Dafür definieren wir drei Klassen:
\begin{itemize}
    \item \texttt{OrderService}: Klasse, die die Bestellungen verwaltet
    \item \texttt{PaymentService}: Klasse, die die Zahlungen abwickelt
    \item \texttt{ShipmentService}: Klasse, die die Lieferungen initiiert
\end{itemize}

Die Kommunikation zwischen den Klassen erfolgt durch Methodenaufrufe.
Dabei ist die Klasse \texttt{OrderService} die Hauptklasse, die die
Methoden der anderen Klassen verwendet, um den Bestellungsvorgang durchzuführen.
Vorteilhaft hier ist, dass hier die Kommunikation zwischen den komponenten einfach ist.
Durch die Verwendung von Methodenaufrufen wird die Komplexität reduziert, die mit
Intersystemkommunikationen verbunden ist.

Jedoch, wenn die Code-Basis wächst und komplex wird, treten einige Nachteile auf.
Durch Änderungen in einer Komponente können unerwartete kaskadierende Fehler
ausgelöst werden, was die Weiterentwicklung in kleinen autonomen
Teams erschwert und verlangsamt.

Außerdem durch die Verwendung von direkte Methodenaufrufe, entsteht eine enge Kopplung
zwischen den Komponenten.
Änderungen in der Implementierung oder Signatur einer Methode können die gesamte
 Anwendung beeinflussen.

Weiterhin ist die Wiederverwendung von Funktionalitäten nicht möglich, da die
Komponenten eng gekoppelt sind.
Das führt zu Duplikation von Code, was
die Änderungen teurer macht, da die Änderungen in mehreren Stellen durchgeführt werden müssen.

Die dadurch erhöhte Komplexität und die schwierige Wartung führen zu längere Iterationen.
Da das Deployment nur als Ganzes erfolgt und die Iterationen länger dauern,
kommt es zu seltenen Auslieferungen von neuen Features.

Ferner ist Horizontale Skalierung auch nicht möglich, da die Anwendung nur als Ganzes
skaliert werden kann.
Insgesamt ist die Monolithic Architecture eine gute Einstiegslösung, allerdings nicht für größere Anwendungen geeignet, da
 die Agilität davon stark betroffen werden kann.

\subsection{Modular Monolith}
Das Hauptproblem der vorherigen Architektur war die eng gekoppelte Natur der Architektur,
die eine gewisse Komplexität und Unflexibilität mit sich bringt.
Die Modular Monolithic Architecture ist eine Evolution der Monolithic Architecture, die die Vorteile
der Monolithic Architecture erbt und gleichzeitig die Nachteile der enge Kopplung reduziert.

In diese Architektur wird die Code-Basis in mehrere Module geteilt, die jeweils
eine Teil-Funktionalität der Anwendung implementieren.
Die Kommunikation zwischen den Module erfolgt durch klar definierte Interfaces,
wobei die Wiederverwendbarkeit und Austauschbarkeit der Module ermöglicht wird.\cite[11]{modular-mono2}

Die Trennung in Modulen reduziert zudem die Komplexität und fördert eine bessere
 Organization der Code-Basis, was zu einer bessere Wartbarkeit führt.\cite[23 - 24]{modular-mono4}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.4\textwidth]{images/mono/mono-example.pdf}
    \caption{Modular Monolith Architektur}
    \label{fig:modular-mono}
\end{figure}

Betrachten wir erneut das E-Commerce-Beispiel.
Diesmal wird die Anwendung in drei Hauptmodule aufgeteilt (Siehe Abb. ~\ref{fig:modular-mono}):
\begin{itemize}
    \item \texttt{OrderModule}: Verantwortlich für die Verwaltung der Bestellungen
    \item \texttt{PaymentModule}: Verantwortlich für die Abwicklung der Zahlungen
    \item \texttt{ShipmentModule}: Verantwortlich für die Initiierung der Lieferungen
\end{itemize}

Abhängigkeiten zwischen den Modulen werden durch die Verwendungen von Interfaces
reduziert, indem die Module nur die Schnittstellen kennen und nicht die Implementierung.
Zum Beispiel Änderungen an der Implementierung einer Komponente von \texttt{PaymentModule} müssen nur
in der Implementierung des Interfaces durchgeführt werden, ohne dass die anderen
abhängigen Module davon betroffen werden.
Die Modularisierung ermöglicht zusätzlich eine verbesserte Entwicklung in semi-autonomen Teams im
Vergleich zu den traditionellen Monolithen.
Problematisch ist jedoch, dass die Anwendung nur als Ganzes deployt werden kann, was
die Iterationen verlangsamt.
Außerdem ist weiterhin keine horizontale Skalierung möglich und die Funktionalitäten
können nicht wiederverwendet werden, da diese immer noch Teil einer einzigen Anwendung
und eng miteinander gekoppelt sind.

\subsection{Layered}
Die Layerd Architektur wählt als Basis Schichten (englisch \textit{layers}), die eine
Anwendung in verschiedenen Schichten aufteilt.
Die Anzahl oder Aufgabe der Schichten werden von der Architekturmuster nicht vorgegeben. ~\cite [34]{layered2}

Demnach kann ein Unternehmen die Anzahl und die Aufgaben der Schichten nach den eigenen
Bedürfnisse definieren.

Allerdings sind einigen Prinzipien von der Architekturmuster zu beachten, um von Vorteile
wie die Wartbarkeit, Skalierbarkeit und die Wiederverwendbarkeit zu profitieren.~\cite [34]{layered2}

Ein wichtiges Prinzip der Layered Architecture ist der die Trennung der Zuständigkeiten
(Englisch \textit{Separation of concerns}). Komponenten mit unterschiedlichen Aufgaben sollten
auf verschiedene Schichten verteilt werden, sodass die Komponenten einer Schicht jeweils für
eine klar definierte und gemeinsame Aufgabe zuständig sind. \cite[34]{layered2}

Ein weiteres Prinzip der Layered Architecture ist der Isolation von Schichten (Englisch \textit{layers of isolation}).
Dies besagt, dass die Kommunikation zwischen Schichten ausschließlich über definierte Verträge erfolgt.
\cite[3 - 4]{layered}

In Kontext eines Unternehmens kann die Layered Architecture genutzt werden, um häufige
 Funktionalitäten in Schichten zu kapseln und diese in anderen Teilen des Unternehmens wiederzuverwenden.

Jede Schicht müsste dabei eine klare Aufgabe haben, um die Trennung der Zuständigkeiten zu gewährleisten.
Außerdem sollte die Schicht über eine klare Schnittstelle verfügen, die die Kommunikation ermöglicht und
die Implementierung der Schicht versteckt.

Dadurch wird die Isolation der Schicht gemäß der Prinzip der Isolation von Schichten garantiert, sodass Änderungen
in einer Schicht das System nicht beeinflussen.

Außerdem kann die Layered Architecture mit agilen Architekturmuster wie Microservices
kombiniert werden, um die Agilität des Unternehmens zu weiter zu erhöhen.

Betrachten wir erneut das E-Commerce-Beispiel.
In der vorherigen Implementierung würde die Anwendung in drei Services implementiert,
die jeweils für die Verwaltung der Bestellungen, Zahlungen und Lieferungen zuständig sind.
Innerhalb der einzelnen Services ist einen Modul für die Authentifizierung
implementiert.
Problematisch ist jedoch, dass diese Module in jedem Service dupliziert sind,
was die Wartbarkeit erschwert und die Änderungen teurer macht.
Änderungen in einem Modul müssen in allen Services durchgeführt werden, was die
Entwicklung verlangsamt.
Lösung hierfür ist die Implementierung der Authentifizierung in einer
eigenen Schicht auszulagern.
Die Kommunikation ist folglich über eine REST-Schnittstelle über den API-Gateway möglich.(Siehe Abb. ~\ref{fig:layered})

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.5\textwidth]{images/layered/ecommerce-example}
    \caption{Layered Architektur }
    \label{fig:layered}
\end{figure}

Mit Einführung der Authentifizierungsschicht kann bei Bedarf die Authentifizierung
in einer einzigen Stelle geändert werden, ohne dass die Änderungen in anderen Services
vorgenommen werden müssen.

In einem Unternehmen der zahlreiche Services betriebt, kann das zu einer erheblichen
Kosten- und Zeiteinsparung führen.

Ein weiterer Vorteil besteht darin, dass die Authentifizierung für sämtliche Dienste lediglich
einmalig durchgeführt werden muss, da diese einmalig durch das API-Gateway erfolgt.
 Dies eliminiert die Notwendigkeit, dass jeder einzelner Dienst die Authentifizierung erneut durchführen muss.

Zudem durch den Einsatz von der Layered Architecture Services müssen sich nur
 um ihre eigene Funktionalitäten kümmern und nicht um die Authentifizierung.

Dadurch wird eine bessere Trennung der Concerns erreicht, was die Zusammenarbeit
 in kleine autonome Teams noch weiter fördert.

Die lose Kopplung der einzelnen Schichten zueinander, die durch die Schnittstellen entsteht,
ermöglicht deren Austauschbarkeit und Änderungen.
Dies resultiert in einer hohen Flexibilität.

Das Beispiel hat außerdem gezeigt, dass die Layered Architecture, mit anderen agilen
Architekturen wie Microservices, eine exzellente kombinierbare Architektur ist und
folglich die Agilität des Unternehmens signifikant erhöht.

\section{Moderne Enterprise-Architekturen}

\subsection{Event-Driven Architecture}
Die Event-Driven Architecture wählt als Basis einen anderen Ausgangspunkt als die bisherigen Architekturmuster.
Während bei letzteren Komponenten Dienste bereitstellen, welche von anderen Komponenten explizit genutzt werden,
verhalten sich Dienst-bereitstellende Komponenten in der Event-Driven Architecture reaktiv,
werden also implizit von Dienst-konsumierenden Komponenten genutzt \cite{garlanShawImplizit}.
Ein System reagiert somit asynchron auf Zustandsänderungen, also Ereignisse in diesem System \cite{eda}.
Die in dieser Architektur minimalen Einheiten, welche Informationen einer Zustandsänderung kapseln, werden \textit{Events} genannt.
Die Idee der impliziten Behandlung von Ereignissen ist nicht neu und taucht erstmals 1994 im von Garlan und Shaw publizierten Papier
\textit{\enquote{An introduction to Software Architecture}} auf.

Betrachten wir im Folgenden die Basis-Bestandteile der Event-Driven Architecture:
\begin{itemize}
  \item Ereignis (englisch \textit{Event}): Kapselt Information einer Zustandsänderung eines Systems
  \item Produzent (englisch \textit{Producer}): Komponente, die Event erzeugt
  \item Herausgeber (englisch \textit{Publisher}): Komponente, die, von Produzenten erzeugte, Events publiziert
  \item Konsument (englisch \textit{Consumer}): Reagiert auf publizierte Events
  \item Vermittler (englisch \textit{Mediator}): Liegt zwischen Produzenten und Konsumenten - filtert Events und verteilt diese auf Konsumenten
  \item Event-Bus: Oft auch \textit{Event-Broker} genannt - bietet die Infrastruktur für die Gesamtheit der Vermittler
\end{itemize}
Abstrakt kann ein Event als ein Vertrag zwischen Produzenten und Konsumenten am Event-Bus betrachtet werden.
Der Konsument nutzt die Spezifikation des Events am Bus, der Produzent implementiert jene Spezifikation.
Abbildung \ref{fig:eda} stellt diesen Vertrag dar.

\begin{figure}[!h]
  \centering
  \includegraphics[width=\linewidth]{images/eda/eda.drawio}
  \caption{Vertrag zwischen Produzenten und Konsumenten am Event-Bus}
  \label{fig:eda}
\end{figure}

Durch den Vertrag weisen die Events am Event-Bus starke Kohäsion und somit lose Kopplung auf.
Diese lose Kopplung minimiert nicht nur kaskadierende Fehler, sondern ermöglicht agilen Entwickler-Teams durch klar abgegrenzte Features einfach definierbare Iterationen
- eine Menge von Events, deren Erzeugung und Konsumierung.

Weiter sind Events oft nah an dem, was Ereignisse in realen Prozessen sind, also domain-driven.
Gebündelt ermöglichen obige Punkte die kontinuierliche Auslieferung von Software in kurzen Intervallen.

Außerdem garantiert die asynchrone Behandlung von Ereignissen zusammen mit der loosen Kopplung maximale Skalierung.
Daher sind Event-Driven Architekturen besonders für datenintensive Echtzeit-Anwendungen wie IoT (Internet of Things) und Analytics geeignet \cite{iotEda}.

Die Agilität der Architektur kann weiter erhöht werden, indem der event-basierte Aspekt mit weiteren agilen Strukturen wie Microservices oder cloud-nativen Serverless-Functions kombiniert wird.
Die damit einhergehende Komplexität stellt teilweise hohe Anforderungen an die Entwickler.
Aufgrund der Asynchronität der Behandlung von Ereignissen ist die Testung des Systems meist schwer und die Fehlerbehandlung essentiell.
Mögliche Problemquellen schließen dabei unter anderem Event-Verlust, erhöhte Latenz und Inkonsistenz ein.
Die hohen Anforderungen an die Entwickler verlangen viel Vertrauen in jene, einer der zentralen Punkte des agilen Manifests \cite{agileManifesto}.
Insgesamt weist die Event-Driven Architecture also eine sehr hohe Agilität auf und ist damit besonders für moderne Software und ihre stetig wechselnden Anforderungen geeignet.

% TODO: Jetzt bestenfalls übergreifendes Beispiel

\section{Fallstudien und Praxisbeispiele}
Blah \ldots

\section{Diskussion}

\section{Zusammenfassung und Ausblick}
%(Überblick über die gesamte Arbeit, Rückführung auf Aussagen aus Kapitel 1 durchführen, offene Punkte als neue Forschungsfragen definieren)






\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\appendix

\section{Anhang 1}

\subsection{Übungsaufgaben}
Blah \ldots

\section{Anhang 2}
Blah \ldots

\end{document}
\endinput
